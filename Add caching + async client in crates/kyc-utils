*** Begin Patch
*** Update File: crates/kyc-utils/Cargo.toml
@@
 [dependencies]
 serde = { version = "1.0", features = ["derive"] }
 solana-client = "1.17"
 solana-sdk = "1.17"
 async-trait = "0.1"
 tokio = { version = "1", features = ["full"] }
 anyhow = "1.0"
+dashmap = "5.5"
+rocksdb = { version = "0.21", optional = true }
+serde_json = "1.0"
+
+[features]
+default = []
+persistent-cache = ["rocksdb"]
*** End Patch
*** Add File: crates/kyc-utils/src/cache.rs
+use std::sync::Arc;
+use dashmap::DashMap;
+use solana_sdk::pubkey::Pubkey;
+use anyhow::Result;
+
+#[cfg(feature = "persistent-cache")]
+use rocksdb::DB;
+
+#[derive(Clone)]
+pub struct Cache {
+    memory: Arc<DashMap<String, Vec<u8>>>,
+    #[cfg(feature = "persistent-cache")]
+    db: Option<Arc<DB>>,
+}
+
+impl Cache {
+    pub fn new() -> Self {
+        #[cfg(feature = "persistent-cache")]
+        {
+            let db = DB::open_default("kyc_cache.db").ok();
+            Self {
+                memory: Arc::new(DashMap::new()),
+                db: db.map(Arc::new),
+            }
+        }
+
+        #[cfg(not(feature = "persistent-cache"))]
+        {
+            Self {
+                memory: Arc::new(DashMap::new()),
+            }
+        }
+    }
+
+    pub fn set(&self, key: &str, value: Vec<u8>) {
+        self.memory.insert(key.to_string(), value.clone());
+        #[cfg(feature = "persistent-cache")]
+        if let Some(db) = &self.db {
+            let _ = db.put(key, value);
+        }
+    }
+
+    pub fn get(&self, key: &str) -> Option<Vec<u8>> {
+        if let Some(val) = self.memory.get(key) {
+            return Some(val.clone());
+        }
+        #[cfg(feature = "persistent-cache")]
+        if let Some(db) = &self.db {
+            if let Ok(Some(v)) = db.get(key) {
+                self.memory.insert(key.to_string(), v.clone());
+                return Some(v);
+            }
+        }
+        None
+    }
+}
*** End Patch
*** Add File: crates/kyc-utils/src/rpc_client.rs
+use solana_client::nonblocking::rpc_client::RpcClient;
+use solana_sdk::pubkey::Pubkey;
+use anyhow::Result;
+use tokio::sync::Mutex;
+use std::sync::Arc;
+
+use crate::cache::Cache;
+
+#[derive(Clone)]
+pub struct CachedRpc {
+    pub client: Arc<RpcClient>,
+    pub cache: Arc<Cache>,
+}
+
+impl CachedRpc {
+    pub fn new(endpoint: &str) -> Self {
+        Self {
+            client: Arc::new(RpcClient::new(endpoint.to_string())),
+            cache: Arc::new(Cache::new()),
+        }
+    }
+
+    pub async fn get_account_data_cached(&self, key: &Pubkey) -> Result<Vec<u8>> {
+        let cache_key = key.to_string();
+        if let Some(val) = self.cache.get(&cache_key) {
+            return Ok(val);
+        }
+        let data = self.client.get_account_data(key).await?;
+        self.cache.set(&cache_key, data.clone());
+        Ok(data)
+    }
+}
*** End Patch